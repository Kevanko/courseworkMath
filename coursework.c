#include <stdio.h>

#define N 2798148 // Общая популяция
#define STEPS 91  // Количество шагов по времени

int main() {
    // Инициализация параметров модели
    double αE = 0.999; // Параметр заражения между бессимптомной и восприимчивой группами населения
    double αI = 0.999; // Параметр заражения между инфицированным и восприимчивым населением
    double κ = 0.042;  // Частота появления симптомов у бессимптомных инфицированных
    double ρ = 0.952;  // Скорость восстановления выявленных бессимптомных случаев
    double β = 0.999;  // Скорость выздоровления инфицированных случаев
    double μ = 0.0188; // Смертность в результате COVID-19
    double cisol = 0;  // Коэффициент влияния индекса самоизоляции на заражаемость
    double y = 0;      // Скорость повторного заражения(устойчивый иммунитет)

    // Шаг по времени
    double h = 1;

    // Массивы для хранения решений
    double t[STEPS];
    double S[STEPS];
    double E[STEPS];
    double I[STEPS];
    double R[STEPS];
    double D[STEPS];

    // Начальные условия
    double S0 = N - 99 - 24; // Начальное количество восприимчивых индивидуумов
    double E0 = 99;          // Начальное количество бессимптомных инфицированных
    double I0 = 0;           // Начальное количество инфицированных с симптомами
    double R0 = 24;          // Начальное количество вылеченных индивидуумов
    double D0 = 0;           // Начальное количество умерших

    // Начальные условия
    t[0] = 0;
    S[0] = S0;
    E[0] = E0;
    I[0] = I0;
    R[0] = R0;
    D[0] = D0;

    // Метод Эйлера
    for (int i = 0; i < STEPS - 1; i++) {
        // Функция ограничения передвижения
        double c = 1 + cisol * (1 - 2.0 / 5.0 * 0);

        // Вычисление производных на текущем шаге
        double dS = -c * (αI * S[i] * I[i] / N + αE * S[i] * E[i] / N) + y * R[i];
        double dE = c * (αI * S[i] * I[i] / N + αE * S[i] * E[i] / N) - (κ + ρ) * E[i];
        double dI = κ * E[i] - β * I[i] - μ * I[i];
        double dR = β * I[i] + ρ * E[i] - y * R[i];
        double dD = μ * I[i];

        // Обновление решений на следующем шаге
        t[i + 1] = t[i] + h;
        S[i + 1] = S[i] + h * dS;
        E[i + 1] = E[i] + h * dE;
        I[i + 1] = I[i] + h * dI;
        R[i + 1] = R[i] + h * dR;
        D[i + 1] = D[i] + h * dD;
    }

    // Вывод решения
    printf("t\tS\tE\tI\tR\tD\n");
    for (int i = 0; i < STEPS; i++) {
        printf("%.1f\t%.2f\t%.2f\t%.2f\t%.2f\t%.2f\n", t[i], S[i], E[i], I[i], R[i], D[i]);
    }

    return 0;
}
